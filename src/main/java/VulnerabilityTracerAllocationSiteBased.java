import com.google.common.collect.BiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.MavenCoordinate;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.analyzer.javacgopal.data.exceptions.MissingArtifactException;
import eu.fasten.analyzer.javacgopal.data.exceptions.OPALException;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.maven.utils.MavenUtilities;
import eu.fasten.core.merge.LocalMerger;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


public class VulnerabilityTracerAllocationSiteBased extends Tracer {

    private static void safeCleanDirectory(File dir) {
        try {
            //Clean direcotry
            FileUtils.cleanDirectory(dir);
        } catch (IOException e) {

        }
    }

    @Override
    public void traceProjectVulnerabilities(File project, MavenCoordinate[] dependencyCoordinates, String projectName, String link, String branch, ProjectInfo projectInfo)
            throws MissingArtifactException, IOException, ParseException {
        //Create folder to put in all jars
        File jarDir = new File("callGraphGenerationJars");
        jarDir.mkdir();

        for (MavenCoordinate coord : dependencyCoordinates) {
            DirectedGraph mergedDirectedGraph;
            BiMap<Long, String> allUris;
            File depFile = new MavenCoordinate.MavenResolver().downloadArtifact(coord, MavenUtilities.MAVEN_CENTRAL_REPO);

            safeCleanDirectory(jarDir);
            try {
                System.out.println("CREATING AllocationSiteBasedPointsTo CG");
                List<ExtendedRevisionJavaCallGraph> depSet = new ArrayList<>();

                System.out.println("COPYING JARS TO JAR FOLDER");
                Files.copy(project.toPath(), new File(jarDir.getPath() + File.separator + projectName + ".jar").toPath(), StandardCopyOption.REPLACE_EXISTING);
                depFile.renameTo(new File(jarDir.getPath() + File.separator + depFile.getName()));
                System.out.println("DONE COPYING");

                CallGraphConstructor cgc = new CallGraphConstructor(jarDir, "", "AllocationSiteBasedPointsTo");
                System.out.println("CREATED AllocationSiteBasedPointsTo CG");

                final PartialCallGraph cgDep = new PartialCallGraph(cgc, true);
                final ExtendedRevisionJavaCallGraph bigRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
                        .graph(cgDep.getGraph())
                        .classHierarchy(cgDep.getClassHierarchy())
                        .nodeCount(cgDep.getNodeCount())
                        .build();

                depSet.add(bigRCG);

                LocalMerger merger = new LocalMerger(depSet);
                mergedDirectedGraph = merger.mergeAllDeps();
                allUris = merger.getAllUris();

            } catch (OPALException e) {
                String result = "AllocationSiteBasedPointsTo algorithm failed on " + coord.getArtifactID() + ":"
                        + coord.getGroupID() + " in project " + projectName + "\n";
                System.out.println(result);
                Writer output = new FileWriter(Const.LOG_FILE_PATH, true);
                output.append(result);
                output.close();
                continue;
            }

            JSONParser jsonParser = new JSONParser();
            JSONObject pkgCves = (JSONObject) jsonParser.parse(
                    new FileReader("src/main/resources/pkg_cves.json"));

            List<String> vulnDeps = new ArrayList<>();

            vulnDeps.add(coord.getGroupID() + ":" + coord.getArtifactID());

            for (String vulnDep : vulnDeps) {
                // For each vulnerable dep, get CVE
                JSONArray cves = (JSONArray) pkgCves.get(vulnDep);

                boolean isVulnerable = false;
                for (Object cve_obj : cves) {
                    // For each CVE, get vulnerable methods
                    JSONObject cve = (JSONObject) cve_obj;
                    JSONArray vulnUrisJson = (JSONArray) cve.get("vulnerable_fasten_uris");
                    List<String> vulnUrisList = new ArrayList<>();
                    for (Object str_obj : vulnUrisJson) {
                        vulnUrisList.add((String) str_obj);
                    }
                    var tmp = new String[vulnUrisList.size()];
                    String[] vulnUris = vulnUrisList.toArray(tmp);

                    System.out.println("TRACING METHODS FOR " + cve.get("id"));
                    // And find affected methods
                    Set<ImpactPoint> results = getAffectedMethods(mergedDirectedGraph, allUris, vulnUris, projectName);
                    System.out.println("POINTS OF IMPACT: " + results.size());
                    if (results.size() > 0) {
                        isVulnerable = true;
                        String cveString = (String) cve.get("id");
                        String commonFilePath = "-" + projectInfo.getUser() +
                                "__" + projectName + projectInfo.getRelativeDirectoryPath("__")
                                + "__" + cveString + ".txt";
                        writeOutputOldFormat(
                                "analysisResults/ASB-old-format" + commonFilePath, projectName, link, vulnDep, results
                        );
                        writeOutput(
                                "analysisResults/ASB" + commonFilePath, projectName, link, vulnDep, results
                        );
                    }
                }
                logResults(isVulnerable, projectInfo, projectName, vulnDep);
            }
        }
    }
}
