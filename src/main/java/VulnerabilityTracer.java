import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.MavenCoordinate;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.analyzer.javacgopal.data.exceptions.MissingArtifactException;
import eu.fasten.analyzer.javacgopal.data.exceptions.OPALException;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.maven.utils.MavenUtilities;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


public class VulnerabilityTracer extends Tracer {

    static ExtendedRevisionJavaCallGraph getProjectCG(File project, String projectName, String branch) throws OPALException {
        System.out.println("CREATING RTA CALL GRAPH FOR PROJECT");
        final CallGraphConstructor projectRTACG = new CallGraphConstructor(project, "", "RTA");
        final PartialCallGraph cgRTA = new PartialCallGraph(projectRTACG, true);
        return ExtendedRevisionJavaCallGraph.extendedBuilder()
                .graph(cgRTA.getGraph())
                .product(projectName)
                .version(branch)
                .classHierarchy(cgRTA.getClassHierarchy())
                .nodeCount(cgRTA.getNodeCount())
                .build();
    }

    @Override
    public void traceProjectVulnerabilities(File project, MavenCoordinate[] dependencyCoordinates, String projectName, String link, String branch, ProjectInfo projectInfo)
            throws OPALException, IOException, ParseException {
        final var cg = getProjectCG(putEverythingInDir(project, dependencyCoordinates), projectName,
            branch);

        DirectedGraph mergedDirectedGraph = ExtendedRevisionJavaCallGraph.toLocalDirectedGraph(cg);
        BiMap<Long, String> allUris = convertToLong(cg.mapOfFullURIStrings());

        for (MavenCoordinate coord : dependencyCoordinates) {

            //Read in data about vulnerabilities
            JSONParser jsonParser = new JSONParser();
            JSONObject pkgCves = (JSONObject) jsonParser.parse(
                    new FileReader("src/main/resources/pkg_cves.json"));

            var vulnDep = coord.getGroupID() + ":" + coord.getArtifactID();
                // For each vulnerable dependency, get CVE
                JSONArray cves = (JSONArray) pkgCves.get(vulnDep);

                boolean isVulnerable = false;
                for (Object cve_obj : cves) {
                    // For each CVE, get vulnerable methods
                    JSONObject cve = (JSONObject) cve_obj;

                    String[] vulnUris = toArrayOfStrings((JSONArray) cve.get("vulnerable_fasten_uris"));

                    System.out.println("TRACING METHODS FOR " + cve.get("id"));

                    //Find affected methods for the current CVE
                    Set<ImpactPoint> results = getAffectedMethods(mergedDirectedGraph, allUris, vulnUris, projectName);
                    System.out.println("POINTS OF IMPACT: " + results.size());

                    String cveString = (String) cve.get("id");
                    if (results.size() > 0) {
                        isVulnerable = true;
                        String commonFilePath = "-" + projectInfo.getUser() +
                                "__" + projectName + projectInfo.getRelativeDirectoryPath("__")
                                + "__" + cveString + ".txt";
                        writeOutputOldFormat(
                                "analysisResults/RTA-old-format" + commonFilePath, projectName, link, vulnDep, results
                        );
                        writeOutput(
                                "analysisResults/RTA" + commonFilePath, projectName, link, vulnDep, results
                        );
                    }

                    logResults(isVulnerable, projectInfo, projectName, vulnDep, cveString);
                }

        }
    }

    private BiMap<Long, String> convertToLong(BiMap<Integer, String> mapOfFullURIStrings) {
        final BiMap<Long, String> result = HashBiMap.create();
        for (final var integerStringEntry : mapOfFullURIStrings.entrySet()) {
            result.put(integerStringEntry.getKey().longValue(), integerStringEntry.getValue());
        }
        return result;
    }

    public static File putEverythingInDir(File project, MavenCoordinate[] mavenCoordinates)
        throws IOException {

        final var resultDir = Files.createTempDirectory("fasten").toAbsolutePath();
        Files.copy(project.toPath(),
            Paths.get(resultDir + "/Application.jar"),
            StandardCopyOption.REPLACE_EXISTING);

        for (final var coord : mavenCoordinates) {
            File coordinateFile = new File("");
            try {
                coordinateFile = new MavenCoordinate.MavenResolver().downloadArtifact(coord, "jar");
            } catch (Exception e) {
                System.out.println("File not found!");
            }
            Files.copy(coordinateFile.toPath(),
                Paths.get(resultDir + "/" + coord.getCoordinate() + ".jar"),
                StandardCopyOption.REPLACE_EXISTING);
        }
        return resultDir.toFile();
    }

    private static String[] toArrayOfStrings(JSONArray vulnUrisJson) {
        List<String> vulnUrisList = new ArrayList<>();
        for (Object str_obj : vulnUrisJson) {
            vulnUrisList.add((String) str_obj);
        }
        var tmp = new String[vulnUrisList.size()];
        return vulnUrisList.toArray(tmp);
    }
}
