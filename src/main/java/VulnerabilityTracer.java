import com.google.common.collect.BiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.MavenCoordinate;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.analyzer.javacgopal.data.exceptions.MissingArtifactException;
import eu.fasten.analyzer.javacgopal.data.exceptions.OPALException;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.maven.utils.MavenUtilities;
import eu.fasten.core.merge.LocalMerger;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


public class VulnerabilityTracer {

    static final int MAX_METHOD_TRACING = 30000;

    public static void traceProjectVulnerabilities(File project, MavenCoordinate[] dependencyCoordinates, String projectName, String link) throws OPALException, MissingArtifactException, IOException, ParseException, ParseException {

        System.out.println("CREATING CALL GRAPH FOR PROJECT");
        final CallGraphConstructor opalCG = new CallGraphConstructor(project, "", "CHA");
        final PartialCallGraph cg = new PartialCallGraph(opalCG, true);
        final ExtendedRevisionJavaCallGraph mainRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
            .graph(cg.getGraph())
            .product(projectName)
            .version("develop-snapshot") //TODO can be removed maybe
            .classHierarchy(cg.getClassHierarchy())
            .nodeCount(cg.getNodeCount())
            .build();

        System.out.println("CREATED PROJECT CG");

        List<ExtendedRevisionJavaCallGraph> depSet = new ArrayList<>();
        depSet.add(mainRCG);

        for(MavenCoordinate coord : dependencyCoordinates) {

            File depFile = new MavenCoordinate.MavenResolver().downloadArtifact(coord, MavenUtilities.MAVEN_CENTRAL_REPO);

            final CallGraphConstructor opalCGDep = new CallGraphConstructor(depFile, "", "CHA");
            final PartialCallGraph cgDep = new PartialCallGraph(opalCGDep, true);
            final ExtendedRevisionJavaCallGraph depRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
                .graph(cgDep.getGraph())
                .product(coord.getProduct())
                .version(coord.getVersionConstraint())
                .classHierarchy(cgDep.getClassHierarchy())
                .nodeCount(cgDep.getNodeCount())
                .build();

            depSet.add(depRCG);
        }
        System.out.println("MERGING CALL GRAPHS");
        LocalMerger merger = new LocalMerger(depSet);
        DirectedGraph mergedDirectedGraph = merger.mergeAllDeps();
        BiMap<Long, String> allUris = merger.getAllUris();
        System.out.println("SUCCESSFULLY MERGED");
        //String vURI = "fasten://mvn!com.googlecode.json-simple:json-simple$1.1.1/org.json.simple/JSONObject.%3Cinit%3E()%2Fjava.lang%2FVoidType";

        //Set<Method> result = getAffectedMethods(mergedDirectedGraph, allUris, new String[] {vURI}, projectName);

        //for each vulnerability in this project -> get affected methods

        JSONParser jsonParser = new JSONParser();
        JSONObject pkgCves = (JSONObject) jsonParser.parse(
                new FileReader("src/main/resources/pkg_cves.json"));

        //TODO Execute Chris' POM analyzer to find vulnDeps
        List<String> vulnDeps = new ArrayList<>();

        for(MavenCoordinate coord : dependencyCoordinates) {
            vulnDeps.add(coord.getGroupID() + ":" + coord.getArtifactID());
        }

        //        vulnDeps.add("org.apache.cxf.fediz:fediz-core"); // Example dep

        for (String vulnDep : vulnDeps) {
            // For each vulnerable dep, get CVE
            JSONArray cves = (JSONArray) pkgCves.get(vulnDep);
            Iterator<Object> iterator = cves.iterator();


            for (Object cve_obj : cves) {
                // For each CVE, get vulnerable methods
                JSONObject cve = (JSONObject) cve_obj;
                JSONArray vulnUrisJson = (JSONArray) cve.get("vulnerable_fasten_uris");
                List<String> vulnUrisList = new ArrayList<>();
                for (Object str_obj : vulnUrisJson) {
                    vulnUrisList.add((String) str_obj);
                }
                var tmp = new String[vulnUrisList.size()];
                String[] vulnUris = vulnUrisList.toArray(tmp);

                System.out.println("TRACING METHODS FOR " + cve.get("id"));
                // And find affected methods
                Set<Method> results = getAffectedMethods(mergedDirectedGraph, allUris, vulnUris, projectName);
                System.out.println("AFFECTED METHODS: " + results.size());
                if(results.size() > 0) {
                    try {
                        String cveString = (String) cve.get("id");
                        String filePath = "analysisResults" + File.separator + projectName + "-" + cveString + ".txt";
                        File file = new File(filePath);
                        file.createNewFile();
                        Writer output = new FileWriter(filePath, true);
                        String result = "";
                        result += projectName + "\n";
                        result += link + "\n";
                        result += "Vulnerable dependency: " + vulnDep + "\n";
                        for(Method m : results) {
                            result += ("_____" + m.name + "\n");
                        }
                        output.write(result);
                        output.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    /**
     * Returns the ids corresponding to the method names given in the allUris map.
     * @param allUris allUris
     * @param methodUris the method names
     * @return the id
     */
    public static Set<Method> getMethodIDs(BiMap<Long, String> allUris, String[] methodUris) {
        Set<Method> result = new HashSet<>();

        for(int i = 0; i < methodUris.length; i++) {
            //var tmp = methodUris[i].split("/");
            int counter = 0;
            for(int k = 0; k < methodUris[i].length(); k++) {
                if(methodUris[i].charAt(k) == '/') {
                    counter++;
                }
                if(counter == 3) {
                    methodUris[i] = methodUris[i].substring(k);
                    break;
                }
            }
        }

        for (String uri : methodUris) {
             for (Map.Entry<Long, String> x : allUris.entrySet()) {
                if (x.getValue() != null && x.getValue().contains(uri)) {
                    Method tmp = new Method(x.getKey());
                    tmp.traces.add(new ArrayList<>());
                    result.add(tmp);
                }
            }
        }
        return result;
    }

    /**
     *
     * Returns a list of all affected methods in the project.
     * @param mergedGraph the merged graph of a RCG
     * @param vulnerableMethodUris the vulnerable method in the dependency
     * @return a list of all affected methods in the project
     */
    public static Set<Method> getAffectedMethods(DirectedGraph mergedGraph, BiMap<Long, String> allUris,  String[] vulnerableMethodUris, String projectName) {
        Set<Method> visited = new HashSet<>();
        Set<Method> toBeVisited = getMethodIDs(allUris, vulnerableMethodUris);
        while(!toBeVisited.isEmpty() && visited.size() < MAX_METHOD_TRACING) {
            Set<Method> toBeVisitedNext = new HashSet<>();
            for(Method method : toBeVisited) {

                if(!visited.contains(method)) {
                    visited.add(method);
                }
                mergedGraph.edgesOf(method.id).stream().map(x -> x.leftLong()).forEach(x -> {
                    if(!Method.containsID(visited,x)) {

                        if(Method.containsID(toBeVisitedNext, x)) {
                            //If method will be visited next, then add trace to existing method object
                            /*toBeVisitedNext.forEach(m -> {
                                if(m.id.equals(x)) {
                                    for(List<Long> trace : method.traces) {
                                        List<Long> copy = new ArrayList<>(trace);
                                        copy.add(method.id);
                                        m.traces.add(copy);
                                    }

                                }
                            });*/
                        }
                        else {
                            //If method won't be visited next, add it and add corresponding traces
                            Method toBeAdded = new Method(x);

                            for(List<Long> trace : method.traces) {
                                List<Long> copy = new ArrayList<>(trace);
                                copy.add(method.id);
                                toBeAdded.traces.add(copy);
                            }


                            toBeVisitedNext.add(toBeAdded);
                        }
                    }
                });
            }
            toBeVisited = toBeVisitedNext;
        }

        //TODO to improve performance change way of detecting if method is in correct repo
        visited.forEach(m -> m.name = allUris.get(m.id));
        return visited.stream().filter(m -> m.name.contains(projectName)).collect(Collectors.toSet());
        //return  visited.stream().map(x -> allUris.get(x)).filter(x -> x.contains(projectName)).collect(Collectors.toList());
    }
}
