import com.google.common.collect.BiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.MavenCoordinate;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.analyzer.javacgopal.data.exceptions.MissingArtifactException;
import eu.fasten.analyzer.javacgopal.data.exceptions.OPALException;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.maven.utils.MavenUtilities;
import eu.fasten.core.merge.LocalMerger;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class VulnerabilityTracer {
    public static void main(String[] args) throws OPALException, MissingArtifactException, IOException, ParseException {

        MavenCoordinate depcoord = new MavenCoordinate("com.googlecode.json-simple", "json-simple", "1.1.1", "jar");

        //Pass the path as an argument
        File file = new File(args[0]);

        traceProjectVulnerabilities(file, new MavenCoordinate[] {depcoord}, "helloGraphs");

    }
    public static void traceProjectVulnerabilities(File project, MavenCoordinate[] dependencyCoordinates, String projectName) throws OPALException, MissingArtifactException, IOException, ParseException {

        final CallGraphConstructor opalCG = new CallGraphConstructor(project, "", "CHA");
        final PartialCallGraph cg = new PartialCallGraph(opalCG, true);
        final ExtendedRevisionJavaCallGraph mainRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
            .graph(cg.getGraph())
            .product(projectName)
            .version("develop-snapshot") //TODO can be removed maybe
            .classHierarchy(cg.getClassHierarchy())
            .nodeCount(cg.getNodeCount())
            .build();

        List<ExtendedRevisionJavaCallGraph> depSet = new ArrayList<>();
        depSet.add(mainRCG);

        for(MavenCoordinate coord : dependencyCoordinates) {

            File depFile = new MavenCoordinate.MavenResolver().downloadArtifact(coord, MavenUtilities.MAVEN_CENTRAL_REPO);

            final CallGraphConstructor opalCGDep = new CallGraphConstructor(depFile, "", "CHA");
            final PartialCallGraph cgDep = new PartialCallGraph(opalCGDep, true);
            final ExtendedRevisionJavaCallGraph depRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
                .graph(cgDep.getGraph())
                .product(coord.getProduct())
                .version(coord.getVersionConstraint())
                .classHierarchy(cgDep.getClassHierarchy())
                .nodeCount(cgDep.getNodeCount())
                .build();

            depSet.add(depRCG);
        }

        LocalMerger merger = new LocalMerger(depSet);
        DirectedGraph mergedDirectedGraph = merger.mergeAllDeps();
        BiMap<Long, String> allUris = merger.getAllUris();

        //for each vulnerability in this project -> get affected methods

        JSONParser jsonParser = new JSONParser();
        JSONObject pkgCves = (JSONObject) jsonParser.parse(
                new FileReader("../resources/pkg_cves.json"));

        //TODO Execute Chris' POM analyzer to find vulnDeps
        List<String> vulnDeps = new ArrayList<>();
//        vulnDeps.add("org.apache.cxf.fediz:fediz-core"); // Example dep

        for (String vulnDep : vulnDeps) {
            // For each vulnerable dep, get CVE
            JSONArray cves = (JSONArray) pkgCves.get(vulnDep);
            Iterator<Object> iterator = cves.iterator();


            for (Object cve_obj : cves) {
                // For each CVE, get vulnerable methods
                JSONObject cve = (JSONObject) cve_obj;
                JSONArray vulnUrisJson = (JSONArray) cve.get("vulnerable_fasten_uris");
                List<String> vulnUrisList = new ArrayList<>();
                for (Object str_obj : vulnUrisJson) {
                    vulnUrisList.add((String) str_obj);
                }
                String[] vulnUris = (String[]) vulnUrisList.toArray();

                // And find affected methods
                getAffectedMethods(mergedDirectedGraph, allUris, vulnUris, mainRCG.product);
            }
        }
    }

    /**
     * Takes the intersection of available URIs and the set of known vulnerable URIs in vulnerable_uris.json.
     * The set of methods in projects is assumed to be smaller than the set of known vulnerable methods (6000+).
     * @param vulnData known vulnerable URIs
     * @param allUris available URIs in the analyzed project
     * @return the intersection of URIs
     */
    public static Set<String> getVulnerableUris(JSONObject vulnData, BiMap<Long, String> allUris) {
        String[] groups = (String[]) vulnData.keySet().toArray();
        Iterator<String> usedMethods = allUris.values().iterator();
        Set<String> vulnUris = new HashSet<>();

        while (usedMethods.hasNext()) {
            // For each URI, check whether its package is a vulnerable group.
            // Binary search should work, as the groups are sorted.
            String currentUri = (String) usedMethods.next();
            Pattern groupPattern = Pattern.compile("^(.+?)\\$");
            Matcher match = groupPattern.matcher(currentUri);
            if (match.find() && Arrays.binarySearch(groups, currentUri) >= 0) {
                // Check whether the URI is in the group, again methods are sorted.
                String[] urisInGroup = (String[]) vulnData.get(match.group(1));
                if (Arrays.binarySearch(urisInGroup, currentUri) >= 0) {
                    vulnUris.add(currentUri);
                }
            }
        }
        return vulnUris;
    }

    /**
     * Returns the ids corresponding to the method names given in the allUris map.
     * @param allUris allUris
     * @param methodUris the method names
     * @return the id
     */
    public static Set<Long> getMethodIDs(BiMap<Long, String> allUris, String[] methodUris) {
        Set<Long> result = new HashSet<>();

        for (Map.Entry<Long, String> x : allUris.entrySet()) {
            for (String uri : methodUris) {
                if (x.getValue().equals(uri)) {
                    result.add(x.getKey());
                }
            }
        }
        return result;
    }

    /**
     *
     * Returns a list of all affected methods in the project.
     * @param mergedGraph the merged graph of a RCG
     * @param vulnerableMethodUris the vulnerable method in the dependency
     * @return a list of all affected methods in the project
     */
    public static List<String> getAffectedMethods(DirectedGraph mergedGraph, BiMap<Long, String> allUris,  String[] vulnerableMethodUris, String projectName) {
        Set<Long> visited = new HashSet<>();
        Set<Long> toBeVisited = getMethodIDs(allUris, vulnerableMethodUris);

        //TODO add method tracing
        while(!toBeVisited.isEmpty()) {
            Set<Long> toBeVisitedNext = new HashSet<>();
            for(Long method : toBeVisited) {
                //toBeVisited.remove(method);

                if(!visited.contains(method)) {
                    visited.add(method);
                }
                mergedGraph.edgesOf(method).stream().map(x -> x.leftLong()).forEach(x -> {
                    if(!visited.contains(x)) {
                        toBeVisitedNext.add(x);
                    }
                });
            }
            toBeVisited = toBeVisitedNext;
        }

        //TODO to improve performance change way of detecting if method is in correct repo
        return  visited.stream().map(x -> allUris.get(x)).filter(x -> x.contains(projectName)).collect(Collectors.toList());
    }
}
