import com.google.common.collect.BiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.MavenCoordinate;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.analyzer.javacgopal.data.exceptions.MissingArtifactException;
import eu.fasten.analyzer.javacgopal.data.exceptions.OPALException;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.maven.utils.MavenUtilities;
import eu.fasten.core.merge.LocalMerger;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


public class VulnerabilityTracer extends Tracer {

    static ExtendedRevisionJavaCallGraph getProjectCG(File project, String projectName, String branch) throws OPALException {
        System.out.println("CREATING RTA CALL GRAPH FOR PROJECT");
        final CallGraphConstructor projectRTACG = new CallGraphConstructor(project, "", "RTA");
        final PartialCallGraph cgRTA = new PartialCallGraph(projectRTACG, true);
        return ExtendedRevisionJavaCallGraph.extendedBuilder()
                .graph(cgRTA.getGraph())
                .product(projectName)
                .version(branch) //TODO can be removed maybe
                .classHierarchy(cgRTA.getClassHierarchy())
                .nodeCount(cgRTA.getNodeCount())
                .build();
    }

    static ExtendedRevisionJavaCallGraph getDependencyCG(MavenCoordinate coord) throws OPALException, MissingArtifactException {
        File depFile = new MavenCoordinate.MavenResolver().downloadArtifact(coord, MavenUtilities.MAVEN_CENTRAL_REPO);
        final CallGraphConstructor opalCGDep = new CallGraphConstructor(depFile, "", "RTA");
        final PartialCallGraph cgDep = new PartialCallGraph(opalCGDep, true);
        return ExtendedRevisionJavaCallGraph.extendedBuilder()
                .graph(cgDep.getGraph())
                .product(coord.getProduct())
                .version(coord.getVersionConstraint())
                .classHierarchy(cgDep.getClassHierarchy())
                .nodeCount(cgDep.getNodeCount())
                .build();
    }

    @Override
    public void traceProjectVulnerabilities(File project, MavenCoordinate[] dependencyCoordinates, String projectName, String link, String branch, ProjectInfo projectInfo)
            throws OPALException, MissingArtifactException, IOException, ParseException {
        final ExtendedRevisionJavaCallGraph mainRCG = getProjectCG(project, projectName, branch);
        System.out.println("CREATED RTA PROJECT CG");

        for (MavenCoordinate coord : dependencyCoordinates) {
            DirectedGraph mergedDirectedGraph;
            BiMap<Long, String> allUris;

            List<ExtendedRevisionJavaCallGraph> depSet = new ArrayList<>();
            depSet.add(mainRCG);
            depSet.add(getDependencyCG(coord));

            System.out.println("MERGING CALL GRAPHS");
            LocalMerger merger = new LocalMerger(depSet);
            mergedDirectedGraph = merger.mergeAllDeps();
            allUris = merger.getAllUris();
            System.out.println("SUCCESSFULLY MERGED");

            JSONParser jsonParser = new JSONParser();
            JSONObject pkgCves = (JSONObject) jsonParser.parse(
                    new FileReader("src/main/resources/pkg_cves.json"));

            List<String> vulnDeps = new ArrayList<>();
            vulnDeps.add(coord.getGroupID() + ":" + coord.getArtifactID());
            for (String vulnDep : vulnDeps) {
                // For each vulnerable dep, get CVE
                JSONArray cves = (JSONArray) pkgCves.get(vulnDep);

                boolean isVulnerable = false;
                for (Object cve_obj : cves) {
                    // For each CVE, get vulnerable methods
                    JSONObject cve = (JSONObject) cve_obj;
                    JSONArray vulnUrisJson = (JSONArray) cve.get("vulnerable_fasten_uris");
                    List<String> vulnUrisList = new ArrayList<>();
                    for (Object str_obj : vulnUrisJson) {
                        vulnUrisList.add((String) str_obj);
                    }
                    var tmp = new String[vulnUrisList.size()];
                    String[] vulnUris = vulnUrisList.toArray(tmp);

                    System.out.println("TRACING METHODS FOR " + cve.get("id"));
                    // And find affected methods
                    Set<ImpactPoint> results = getAffectedMethods(mergedDirectedGraph, allUris, vulnUris, projectName);
                    System.out.println("POINTS OF IMPACT: " + results.size());
                    if (results.size() > 0) {
                        isVulnerable = true;
                        String cveString = (String) cve.get("id");
                        String commonFilePath = "-" + projectInfo.getUser() +
                                "__" + projectName + projectInfo.getRelativeDirectoryPath("__")
                                + "__" + cveString + ".txt";
                        writeOutputOldFormat(
                                "analysisResults/RTA-old-format" + commonFilePath, projectName, link, vulnDep, results
                        );
                        writeOutput(
                                "analysisResults/RTA" + commonFilePath, projectName, link, vulnDep, results
                        );
                    }
                }
                logResults(isVulnerable, projectInfo, projectName, vulnDep);
            }
        }
    }
}
