import com.google.common.collect.BiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.MavenCoordinate;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.analyzer.javacgopal.data.exceptions.MissingArtifactException;
import eu.fasten.analyzer.javacgopal.data.exceptions.OPALException;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.maven.utils.MavenUtilities;
import eu.fasten.core.merge.LocalMerger;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.*;
import java.util.stream.Collectors;

import it.unimi.dsi.fastutil.longs.LongLongPair;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


public class VulnerabilityTracer {

    static final int MAX_METHOD_TRACING = 30000;

    public static void traceProjectVulnerabilities(File project, MavenCoordinate[] dependencyCoordinates, String projectName, String link, String branch) throws OPALException, MissingArtifactException, IOException, ParseException, ParseException {

        System.out.println("CREATING CALL GRAPH FOR PROJECT");
        final CallGraphConstructor opalCG = new CallGraphConstructor(project, "", "RTA");
        final PartialCallGraph cg = new PartialCallGraph(opalCG, true);
        final ExtendedRevisionJavaCallGraph mainRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
                .graph(cg.getGraph())
                .product(projectName)
                .version(branch) //TODO can be removed maybe
                .classHierarchy(cg.getClassHierarchy())
                .nodeCount(cg.getNodeCount())
                .build();

        System.out.println("CREATED PROJECT CG");

        for(MavenCoordinate coord : dependencyCoordinates) {
            File depFile = new MavenCoordinate.MavenResolver().downloadArtifact(coord, MavenUtilities.MAVEN_CENTRAL_REPO);
            final CallGraphConstructor opalCGDep = new CallGraphConstructor(depFile, "", "RTA");
            final PartialCallGraph cgDep = new PartialCallGraph(opalCGDep, true);
            final ExtendedRevisionJavaCallGraph depRCG = ExtendedRevisionJavaCallGraph.extendedBuilder()
                    .graph(cgDep.getGraph())
                    .product(coord.getProduct())
                    .version(coord.getVersionConstraint())
                    .classHierarchy(cgDep.getClassHierarchy())
                    .nodeCount(cgDep.getNodeCount())
                    .build();

            List<ExtendedRevisionJavaCallGraph> depSet = new ArrayList<>();
            depSet.add(mainRCG);
            depSet.add(depRCG);

            System.out.println("MERGING CALL GRAPHS");
            LocalMerger merger = new LocalMerger(depSet);
            DirectedGraph mergedDirectedGraph = merger.mergeAllDeps();
            BiMap<Long, String> allUris = merger.getAllUris();
            System.out.println("SUCCESSFULLY MERGED");

            //for each vulnerability in this project -> get affected methods

            JSONParser jsonParser = new JSONParser();
            JSONObject pkgCves = (JSONObject) jsonParser.parse(
                    new FileReader("src/main/resources/pkg_cves.json"));

            List<String> vulnDeps = new ArrayList<>();

            vulnDeps.add(coord.getGroupID() + ":" + coord.getArtifactID());

            for (String vulnDep : vulnDeps) {
                // For each vulnerable dep, get CVE
                JSONArray cves = (JSONArray) pkgCves.get(vulnDep);

                boolean isVulnerable = false;
                for (Object cve_obj : cves) {
                    // For each CVE, get vulnerable methods
                    JSONObject cve = (JSONObject) cve_obj;
                    JSONArray vulnUrisJson = (JSONArray) cve.get("vulnerable_fasten_uris");
                    List<String> vulnUrisList = new ArrayList<>();
                    for (Object str_obj : vulnUrisJson) {
                        vulnUrisList.add((String) str_obj);
                    }
                    var tmp = new String[vulnUrisList.size()];
                    String[] vulnUris = vulnUrisList.toArray(tmp);

                    System.out.println("TRACING METHODS FOR " + cve.get("id"));
                    // And find affected methods
                    Set<ImpactPoint> results = getAffectedMethods(mergedDirectedGraph, allUris, vulnUris, projectName);
                    System.out.println("POINTS OF IMPACT: " + results.size());

                    if (results.size() > 0) {
                        isVulnerable = true;
                        try {
                            String cveString = (String) cve.get("id");
                            String filePath = "analysisResults" + File.separator + projectName + "-" + cveString + ".txt";
                            File file = new File(filePath);
                            file.createNewFile();
                            Writer output = new FileWriter(filePath, true);
                            String result = "";
                            result += projectName + "\n";
                            result += link + "\n";
                            result += "Vulnerable dependency: " + vulnDep + "\n\n";
                            for (ImpactPoint i : results) {
                                result += ("___" + i.affectedMethodName + "\n");
                                result += ("_______" + i.dependencyMethodName + "\n");
                                result += ("___________" + i.originVulnerableMethodName + "\n\n");
                            }
                            output.write(result);
                            output.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }

                try {
                    String filePath;
                    if (!isVulnerable) {
                        filePath = "analysisResults/stats/negative.txt";
                    } else {
                        filePath = "analysisResults/stats/positive.txt";
                    }
                    Writer output = new FileWriter(filePath, true);
                    String result = projectName + " ~ " + vulnDep + "\n";
                    output.append(result);
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }
    }

    /**
     * Returns the ids corresponding to the method names given in the allUris map.
     * @param allUris allUris
     * @param methodUris the method names
     * @return the id
     */
    public static Set<Long> getMethodIDs(BiMap<Long, String> allUris, String[] methodUris) {
        Set<Long> result = new HashSet<>();

        for(int i = 0; i < methodUris.length; i++) {
            //var tmp = methodUris[i].split("/");
            int counter = 0;
            for(int k = 0; k < methodUris[i].length(); k++) {
                if(methodUris[i].charAt(k) == '/') {
                    counter++;
                }
                if(counter == 3) {
                    methodUris[i] = methodUris[i].substring(k);
                    break;
                }
            }
        }

        for (String uri : methodUris) {
            for (Map.Entry<Long, String> x : allUris.entrySet()) {
                if (x.getValue() != null && x.getValue().contains(uri)) {
                    result.add(x.getKey());
                }
            }
        }
        return result;
    }

    /**
     *
     * Returns a list of all affected methods in the project.
     * @param mergedGraph the merged graph of a RCG
     * @param vulnerableMethodUris the vulnerable method in the dependency
     * @return a list of all affected methods in the project
     */
    public static Set<ImpactPoint> getAffectedMethods(DirectedGraph mergedGraph, BiMap<Long, String> allUris,  String[] vulnerableMethodUris, String projectName) {
        Set<ImpactPoint> impacts = new HashSet<>();
        Set<Long> toBeVisited = getMethodIDs(allUris, vulnerableMethodUris);

        for (Long vulnerableMethod : toBeVisited) {
            Queue<Long> q = new LinkedList<>();
            Set<ImpactPoint> localImpacts = new HashSet<>();
            Set<Long> visited = new HashSet<>();

            q.add(vulnerableMethod);
            visited.add(vulnerableMethod);

            System.out.println("CURRENTLY STARTING VISITING METHOD " + allUris.get(vulnerableMethod));
            while (!q.isEmpty()) {
                Long visitedMethod = q.poll();
                var res = mergedGraph.incomingEdgesOf(visitedMethod);
                for (LongLongPair pair : res) {
                    Long callingMethod = pair.leftLong();
                    if (!visited.contains(callingMethod)) {
                        String callingMethodURI = allUris.get(callingMethod);
                        if (callingMethodURI.contains(projectName)) {
                            localImpacts.add(new ImpactPoint(callingMethod, visitedMethod, vulnerableMethod));
                        } else {
                            visited.add(callingMethod);
                            q.add(callingMethod);
                        }
                    }
                }
            }

            System.out.println("METHOD HAS " + localImpacts.size() + " TOTAL IMPACTS:\n");
            for (ImpactPoint i : localImpacts) {
                impacts.add(i);
                System.out.println(allUris.get(i.affectedMethod));
                System.out.println(allUris.get(i.dependencyMethod) + "\n\n");
            }
        }

        for(ImpactPoint i : impacts) {
            i.affectedMethodName = allUris.get(i.affectedMethod);
            i.dependencyMethodName = allUris.get(i.dependencyMethod);
            i.originVulnerableMethodName = allUris.get(i.originVulnerableMethod);
        }

        //TODO to improve performance change way of detecting if method is in correct repo
        return  impacts;
    }
}
