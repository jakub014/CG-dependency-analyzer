apply plugin: 'java'
apply plugin: 'com.jfrog.artifactory'
apply plugin: 'maven'
apply plugin: 'eclipse'
apply plugin: 'groovy'

ext {
    sharedDir        = file("${project.rootDir}/shared")
    sonatype_publish = project.hasProperty('sonatypePublish') ? true : false
}

if (sonatype_publish) {
    apply plugin: 'signing'
}

group = 'com.exactpro.sailfish-gradle-plugin'
version = "${sailfish_version_major}.${sailfish_version_minor}.${sailfish_version_maintenance}"
archivesBaseName = 'sailfish-gradle-plugin'

dependencies {
    compile gradleApi()
    compile localGroovy()

    compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.4'
	compile group: 'org.freemarker', name: 'freemarker', version: '2.3.24-incubating'

    compile group: 'io.fixprotocol.orchestra', name: 'repository-quickfix', version: '1.5.0'

    compile 'commons-io:commons-io:1.4'
    compile 'com.google.guava:guava:18.0'
}

sourceCompatibility = 1.8 //Java version compatibility to use when compiling Java source.
targetCompatibility = 1.8 //Java version to generate classes for.

sourceSets {
    main {
        java {
            srcDirs = []
        }
        groovy {
            srcDirs = ['src/main/java', 'src/main/groovy']
        }
    }
}

buildscript { // artifacrory plugin
    repositories {
        jcenter()
    }
    dependencies {
        classpath(group: 'org.jfrog.buildinfo', name: 'build-info-extractor-gradle', version: '4.4.12')
        classpath(group: 'com.bmuschko', name: 'gradle-tomcat-plugin', version: '2.2.2')
    }
}

wrapper {
    gradleVersion = '6.7.1'
    distributionType = 'all'
}

repositories {
    maven {
        name 'MavenLocal' // for local builds only
        url sharedDir
    }
    jcenter()
}

task zipFixTypes(type: Zip) {
    from ('src/main/resources/fix/')
    include('types.xml')
    classifier = 'fixtypes'
}

artifacts {
    archives zipFixTypes
}

artifactory {
    publish {
        defaults {
            // Reference to Gradle configurations defined in the build script.
            // This is how we tell the Artifactory Plugin which artifacts should be
            // published to Artifactory.
            publishConfigs('archives')
        }
    }
}

uploadArchives {
    repositories {
        mavenDeployer {
            if (sonatype_publish) {
                beforeDeployment { 
                    MavenDeployment deployment -> signing.signPom(deployment) 
                }

                repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2") {
                    authentication(userName: ossrhUsername, password: ossrhPassword)
                }

                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots") {
                    authentication(userName: ossrhUsername, password: ossrhPassword)
                }

                pom.project {
                    name 'Exactpro Sailfish Gradle plugin'
                    packaging 'jar'
                    // optionally artifactId can be defined here 
                    description 'Gradle toolset for Sailfish build. Sailfish is Test automation solution we\'re releasing to open source.'
                    url 'https://github.com/Exactpro/sailfish-gradle-plugin'

                    scm {
                        connection 'scm:git:https://github.com/Exactpro/sailfish-gradle-plugin'
                        developerConnection 'scm:git:https://github.com/Exactpro/sailfish-gradle-plugin'
                        url 'https://github.com/Exactpro/sailfish-gradle-plugin'
                    }

                    licenses {
                        license {
                            name 'The Apache License, Version 2.0'
                            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        }
                    }

                    developers {
                        developer {
                            id 'Nikita-Smirnov-Exactpro'
                            name 'Nikita Smirnov'
                            email 'nikita.smirnov@exactprosystems.com'
                        }
                    }
                }
            } else {
                repository(url: "file://${sharedDir}")

                doLast {
                    // Remove any invalid maven-metadata.xml files that may have been created
                    // for SNAPSHOT versions that are *not* uniquely versioned.
                    pom*.each { pom ->
                        if (pom.version.endsWith('-SNAPSHOT')) {
                            final File artifactDir = new File(rootProject.ext.sharedDir,
                                    pom.groupId.replace('.', '/')
                                        + '/' + pom.artifactId
                                        + '/' + pom.version)
                                delete fileTree(dir: artifactDir, include: 'maven-metadata.xml*')
                        }
                    }
                }
            }
        }
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: classes) {
    classifier = 'javadoc'
    from javadoc
}

artifacts {
    archives sourcesJar, javadocJar
}

if (sonatype_publish) {
    signing {
        sign configurations.archives
    }
}